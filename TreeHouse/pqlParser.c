/** \file
 *  This C source file was generated by $ANTLR version 3.4
 *
 *     -  From the grammar source file : /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g
 *     -                            On : 2013-07-19 14:35:37
 *     -                for the parser : pqlParserParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "pqlParser.h"
/* ----------------------------------------- */





/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */

#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   ppqlParser_##scope##_SCOPE
#define SCOPE_STACK(scope)  ppqlParser_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->ppqlParser_##scope##Top
#define	SCOPE_SIZE(scope)		ctx->ppqlParser_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* Macros for accessing things in the parser
 */

#undef	    PARSER
#undef	    RECOGNIZER
#undef	    HAVEPARSEDRULE
#undef		MEMOIZE
#undef	    INPUT
#undef	    STRSTREAM
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    MATCHT
#undef	    MATCHANYT
#undef	    FOLLOWSTACK
#undef	    FOLLOWPUSH
#undef	    FOLLOWPOP
#undef	    PRECOVER
#undef	    PREPORTERROR
#undef	    LA
#undef	    LT
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    PERRORRECOVERY
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    RECOVERFROMMISMATCHEDSET
#undef	    RECOVERFROMMISMATCHEDELEMENT
#undef		INDEX
#undef      ADAPTOR
#undef		SEEK
#undef	    RULEMEMO
#undef		DBG

#define	    PARSER				ctx->pParser
#define	    RECOGNIZER				PARSER->rec
#define	    PSRSTATE				RECOGNIZER->state
#define	    HAVEPARSEDRULE(r)			RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define	    MEMOIZE(ri,si)			RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define	    INPUT				PARSER->tstream
#define	    STRSTREAM				INPUT
#define	    ISTREAM				INPUT->istream
#define	    INDEX()				ISTREAM->index(INPUT->istream)
#define	    HASEXCEPTION()			(PSRSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION				PSRSTATE->exception
#define	    MATCHT(t, fs)			RECOGNIZER->match(RECOGNIZER, t, fs)
#define	    MATCHANYT()				RECOGNIZER->matchAny(RECOGNIZER)
#define	    FOLLOWSTACK				PSRSTATE->following
#ifdef  SKIP_FOLLOW_SETS
#define	    FOLLOWPUSH(x)
#define	    FOLLOWPOP()
#else
#define	    FOLLOWPUSH(x)			FOLLOWSTACK->push(FOLLOWSTACK, ((void *)(&(x))), NULL)
#define	    FOLLOWPOP()				FOLLOWSTACK->pop(FOLLOWSTACK)
#endif
#define	    PRECOVER()				RECOGNIZER->recover(RECOGNIZER)
#define	    PREPORTERROR()			RECOGNIZER->reportError(RECOGNIZER)
#define	    LA(n)				INPUT->istream->_LA(ISTREAM, n)
#define	    LT(n)				INPUT->_LT(INPUT, n)
#define	    CONSTRUCTEX()			RECOGNIZER->exConstruct(RECOGNIZER)
#define	    CONSUME()				ISTREAM->consume(ISTREAM)
#define	    MARK()				ISTREAM->mark(ISTREAM)
#define	    REWIND(m)				ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()			ISTREAM->rewindLast(ISTREAM)
#define	    SEEK(n)				ISTREAM->seek(ISTREAM, n)
#define	    PERRORRECOVERY			PSRSTATE->errorRecovery
#define	    FAILEDFLAG				PSRSTATE->failed
#define	    HASFAILED()				(FAILEDFLAG == ANTLR3_TRUE)
#define	    BACKTRACKING			PSRSTATE->backtracking
#define	    RECOVERFROMMISMATCHEDSET(s)		RECOGNIZER->recoverFromMismatchedSet(RECOGNIZER, s)
#define	    RECOVERFROMMISMATCHEDELEMENT(e)	RECOGNIZER->recoverFromMismatchedElement(RECOGNIZER, s)
#define     ADAPTOR                         ctx->adaptor
#define		RULEMEMO						PSRSTATE->ruleMemo
#define		DBG								RECOGNIZER->debugger


#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */


/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
pANTLR3_UINT8   pqlParserTokenNames[27+4]
     = {
        (pANTLR3_UINT8) "<invalid>",       /* String to print to indicate an invalid token */
        (pANTLR3_UINT8) "<EOR>",
        (pANTLR3_UINT8) "<DOWN>",
        (pANTLR3_UINT8) "<UP>",
        (pANTLR3_UINT8) "CHARACTER_LITERAL",
        (pANTLR3_UINT8) "COMMENT",
        (pANTLR3_UINT8) "DECIMAL_LITERAL",
        (pANTLR3_UINT8) "EscapeSequence",
        (pANTLR3_UINT8) "FLOATING_POINT_LITERAL",
        (pANTLR3_UINT8) "IDENTIFIER",
        (pANTLR3_UINT8) "LETTER",
        (pANTLR3_UINT8) "LINE_COMMENT",
        (pANTLR3_UINT8) "NEWLINE",
        (pANTLR3_UINT8) "RANGE_LITERAL",
        (pANTLR3_UINT8) "STRING_GUTS",
        (pANTLR3_UINT8) "STRING_LITERAL",
        (pANTLR3_UINT8) "WS",
        (pANTLR3_UINT8) "'!'",
        (pANTLR3_UINT8) "'!='",
        (pANTLR3_UINT8) "'('",
        (pANTLR3_UINT8) "')'",
        (pANTLR3_UINT8) "'+'",
        (pANTLR3_UINT8) "','",
        (pANTLR3_UINT8) "'-'",
        (pANTLR3_UINT8) "'='",
        (pANTLR3_UINT8) "'=='",
        (pANTLR3_UINT8) "'['",
        (pANTLR3_UINT8) "']'",
        (pANTLR3_UINT8) "'^'",
        (pANTLR3_UINT8) "'{'",
        (pANTLR3_UINT8) "'}'"
       };



// Forward declare the locally static matching functions we have generated.
//
static 
 void
	prog    (ppqlParser ctx);
static 
 void
	query    (ppqlParser ctx);
static 
 pqlsymbol *
	assignment_expression    (ppqlParser ctx);
static 
 pqlsymbol *
	not_expression    (ppqlParser ctx);
static 
 pqlsymbol *
	difference_expression    (ppqlParser ctx);
static 
 pqlsymbol *
	union_expression    (ppqlParser ctx);
static 
 pqlsymbol *
	intersection_expression    (ppqlParser ctx);
static 
 pqlsymbol *
	equality_expression    (ppqlParser ctx);
static 
 pqlsymbol *
	postfix_expression    (ppqlParser ctx);
static 
 vector<pqlsymbol * >
	argument_expression_list    (ppqlParser ctx);
static 
 pqlsymbol *
	primary_expression    (ppqlParser ctx);
static 
 pqlsymbol *
	constant_expression_list    (ppqlParser ctx);
static 
 pqlsymbol *
	atom    (ppqlParser ctx);
static 
 pqlsymbol *
	constant    (ppqlParser ctx);
static void	pqlParserFree(ppqlParser ctx);
static void     pqlParserReset (ppqlParser ctx);

/* For use in tree output where we are accumulating rule labels via label += ruleRef
 * we need a function that knows how to free a return scope when the list is destroyed.
 * We cannot just use ANTLR3_FREE because in debug tracking mode, this is a macro.
 */
static	void ANTLR3_CDECL freeScope(void * scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "/home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new pqlParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API ppqlParser
pqlParserNew   (pANTLR3_COMMON_TOKEN_STREAM instream)
{
	// See if we can create a new parser with the standard constructor
	//
	return pqlParserNewSSD(instream, NULL);
}

/** \brief Create a new pqlParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API ppqlParser
pqlParserNewSSD   (pANTLR3_COMMON_TOKEN_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    ppqlParser ctx;	    /* Context structure we will build and return   */

    ctx	= (ppqlParser) ANTLR3_CALLOC(1, sizeof(pqlParser));

    if	(ctx == NULL)
    {
		// Failed to allocate memory for parser context
		//
        return  NULL;
    }

    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * the base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 parser function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function.
     *
     * We don't use the macros defined in pqlParser.h here, in order that you can get a sense
     * of what goes where.
     */

    /* Create a base parser/recognizer, using the supplied token stream
     */
    ctx->pParser	    = antlr3ParserNewStream(ANTLR3_SIZE_HINT, instream->tstream, state);
    /* Install the implementation of our pqlParser interface
     */
    ctx->prog	= prog;
    ctx->query	= query;
    ctx->assignment_expression	= assignment_expression;
    ctx->not_expression	= not_expression;
    ctx->difference_expression	= difference_expression;
    ctx->union_expression	= union_expression;
    ctx->intersection_expression	= intersection_expression;
    ctx->equality_expression	= equality_expression;
    ctx->postfix_expression	= postfix_expression;
    ctx->argument_expression_list	= argument_expression_list;
    ctx->primary_expression	= primary_expression;
    ctx->constant_expression_list	= constant_expression_list;
    ctx->atom	= atom;
    ctx->constant	= constant;
    ctx->free			= pqlParserFree;
    ctx->reset			= pqlParserReset;
    ctx->getGrammarFileName	= getGrammarFileName;

    /* Install the scope pushing methods.
     */

    /* Install the token table
     */
    PSRSTATE->tokenNames   = pqlParserTokenNames;


    /* Return the newly built parser to the caller
     */
    return  ctx;
}

static void
pqlParserReset (ppqlParser ctx)
{
    RECOGNIZER->reset(RECOGNIZER);
}

/** Free the parser resources
 */
 static void
 pqlParserFree(ppqlParser ctx)
 {
    /* Free any scope memory
     */

	// Free this parser
	//
    ctx->pParser->free(ctx->pParser);


    ANTLR3_FREE(ctx);

    /* Everything is released, so we can return
     */
    return;
 }

/** Return token names used by this 
parser

 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static pANTLR3_UINT8    *getTokenNames()
{
        return pqlParserTokenNames;
}


       // Define some general things. 
       // vector< bool * > list_bs; // Move to global?
        //vector<unsigned int> allTrees; // Move to global?
         //std::vector<std::shared_ptr<pqlsymbol> > symbol_table;


/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: FOLLOW_query_in_prog62  */
static	ANTLR3_BITWORD FOLLOW_query_in_prog62_bits[]	= { ANTLR3_UINT64_LIT(0x00000000240A9352) };
static  ANTLR3_BITSET_LIST FOLLOW_query_in_prog62	= { FOLLOW_query_in_prog62_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_assignment_expression_in_query85  */
static	ANTLR3_BITWORD FOLLOW_assignment_expression_in_query85_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_assignment_expression_in_query85	= { FOLLOW_assignment_expression_in_query85_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NEWLINE_in_query106  */
static	ANTLR3_BITWORD FOLLOW_NEWLINE_in_query106_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_NEWLINE_in_query106	= { FOLLOW_NEWLINE_in_query106_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_assignment_expression142  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_assignment_expression142_bits[]	= { ANTLR3_UINT64_LIT(0x0000000001000000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_assignment_expression142	= { FOLLOW_IDENTIFIER_in_assignment_expression142_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_24_in_assignment_expression144  */
static	ANTLR3_BITWORD FOLLOW_24_in_assignment_expression144_bits[]	= { ANTLR3_UINT64_LIT(0x00000000240A8350) };
static  ANTLR3_BITSET_LIST FOLLOW_24_in_assignment_expression144	= { FOLLOW_24_in_assignment_expression144_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_assignment_expression_in_assignment_expression148  */
static	ANTLR3_BITWORD FOLLOW_assignment_expression_in_assignment_expression148_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_assignment_expression_in_assignment_expression148	= { FOLLOW_assignment_expression_in_assignment_expression148_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_not_expression_in_assignment_expression173  */
static	ANTLR3_BITWORD FOLLOW_not_expression_in_assignment_expression173_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_not_expression_in_assignment_expression173	= { FOLLOW_not_expression_in_assignment_expression173_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_17_in_not_expression231  */
static	ANTLR3_BITWORD FOLLOW_17_in_not_expression231_bits[]	= { ANTLR3_UINT64_LIT(0x0000000024088350) };
static  ANTLR3_BITSET_LIST FOLLOW_17_in_not_expression231	= { FOLLOW_17_in_not_expression231_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_difference_expression_in_not_expression242  */
static	ANTLR3_BITWORD FOLLOW_difference_expression_in_not_expression242_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_difference_expression_in_not_expression242	= { FOLLOW_difference_expression_in_not_expression242_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_union_expression_in_difference_expression301  */
static	ANTLR3_BITWORD FOLLOW_union_expression_in_difference_expression301_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800002) };
static  ANTLR3_BITSET_LIST FOLLOW_union_expression_in_difference_expression301	= { FOLLOW_union_expression_in_difference_expression301_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_23_in_difference_expression313  */
static	ANTLR3_BITWORD FOLLOW_23_in_difference_expression313_bits[]	= { ANTLR3_UINT64_LIT(0x0000000024088350) };
static  ANTLR3_BITSET_LIST FOLLOW_23_in_difference_expression313	= { FOLLOW_23_in_difference_expression313_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_union_expression_in_difference_expression319  */
static	ANTLR3_BITWORD FOLLOW_union_expression_in_difference_expression319_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800002) };
static  ANTLR3_BITSET_LIST FOLLOW_union_expression_in_difference_expression319	= { FOLLOW_union_expression_in_difference_expression319_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_intersection_expression_in_union_expression371  */
static	ANTLR3_BITWORD FOLLOW_intersection_expression_in_union_expression371_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000200002) };
static  ANTLR3_BITSET_LIST FOLLOW_intersection_expression_in_union_expression371	= { FOLLOW_intersection_expression_in_union_expression371_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_21_in_union_expression377  */
static	ANTLR3_BITWORD FOLLOW_21_in_union_expression377_bits[]	= { ANTLR3_UINT64_LIT(0x0000000024088350) };
static  ANTLR3_BITSET_LIST FOLLOW_21_in_union_expression377	= { FOLLOW_21_in_union_expression377_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_intersection_expression_in_union_expression383  */
static	ANTLR3_BITWORD FOLLOW_intersection_expression_in_union_expression383_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000200002) };
static  ANTLR3_BITSET_LIST FOLLOW_intersection_expression_in_union_expression383	= { FOLLOW_intersection_expression_in_union_expression383_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_equality_expression_in_intersection_expression440  */
static	ANTLR3_BITWORD FOLLOW_equality_expression_in_intersection_expression440_bits[]	= { ANTLR3_UINT64_LIT(0x0000000010000002) };
static  ANTLR3_BITSET_LIST FOLLOW_equality_expression_in_intersection_expression440	= { FOLLOW_equality_expression_in_intersection_expression440_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_28_in_intersection_expression450  */
static	ANTLR3_BITWORD FOLLOW_28_in_intersection_expression450_bits[]	= { ANTLR3_UINT64_LIT(0x0000000024088350) };
static  ANTLR3_BITSET_LIST FOLLOW_28_in_intersection_expression450	= { FOLLOW_28_in_intersection_expression450_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_equality_expression_in_intersection_expression456  */
static	ANTLR3_BITWORD FOLLOW_equality_expression_in_intersection_expression456_bits[]	= { ANTLR3_UINT64_LIT(0x0000000010000002) };
static  ANTLR3_BITSET_LIST FOLLOW_equality_expression_in_intersection_expression456	= { FOLLOW_equality_expression_in_intersection_expression456_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_postfix_expression_in_equality_expression513  */
static	ANTLR3_BITWORD FOLLOW_postfix_expression_in_equality_expression513_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002040002) };
static  ANTLR3_BITSET_LIST FOLLOW_postfix_expression_in_equality_expression513	= { FOLLOW_postfix_expression_in_equality_expression513_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_25_in_equality_expression517  */
static	ANTLR3_BITWORD FOLLOW_25_in_equality_expression517_bits[]	= { ANTLR3_UINT64_LIT(0x0000000024088350) };
static  ANTLR3_BITSET_LIST FOLLOW_25_in_equality_expression517	= { FOLLOW_25_in_equality_expression517_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_18_in_equality_expression521  */
static	ANTLR3_BITWORD FOLLOW_18_in_equality_expression521_bits[]	= { ANTLR3_UINT64_LIT(0x0000000024088350) };
static  ANTLR3_BITSET_LIST FOLLOW_18_in_equality_expression521	= { FOLLOW_18_in_equality_expression521_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_postfix_expression_in_equality_expression530  */
static	ANTLR3_BITWORD FOLLOW_postfix_expression_in_equality_expression530_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002040002) };
static  ANTLR3_BITSET_LIST FOLLOW_postfix_expression_in_equality_expression530	= { FOLLOW_postfix_expression_in_equality_expression530_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_primary_expression_in_postfix_expression586  */
static	ANTLR3_BITWORD FOLLOW_primary_expression_in_postfix_expression586_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004080002) };
static  ANTLR3_BITSET_LIST FOLLOW_primary_expression_in_postfix_expression586	= { FOLLOW_primary_expression_in_postfix_expression586_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_26_in_postfix_expression597  */
static	ANTLR3_BITWORD FOLLOW_26_in_postfix_expression597_bits[]	= { ANTLR3_UINT64_LIT(0x00000000240A8350) };
static  ANTLR3_BITSET_LIST FOLLOW_26_in_postfix_expression597	= { FOLLOW_26_in_postfix_expression597_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_assignment_expression_in_postfix_expression603  */
static	ANTLR3_BITWORD FOLLOW_assignment_expression_in_postfix_expression603_bits[]	= { ANTLR3_UINT64_LIT(0x0000000008000000) };
static  ANTLR3_BITSET_LIST FOLLOW_assignment_expression_in_postfix_expression603	= { FOLLOW_assignment_expression_in_postfix_expression603_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_27_in_postfix_expression605  */
static	ANTLR3_BITWORD FOLLOW_27_in_postfix_expression605_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004080002) };
static  ANTLR3_BITSET_LIST FOLLOW_27_in_postfix_expression605	= { FOLLOW_27_in_postfix_expression605_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_19_in_postfix_expression630  */
static	ANTLR3_BITWORD FOLLOW_19_in_postfix_expression630_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000100000) };
static  ANTLR3_BITSET_LIST FOLLOW_19_in_postfix_expression630	= { FOLLOW_19_in_postfix_expression630_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_20_in_postfix_expression632  */
static	ANTLR3_BITWORD FOLLOW_20_in_postfix_expression632_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004080002) };
static  ANTLR3_BITSET_LIST FOLLOW_20_in_postfix_expression632	= { FOLLOW_20_in_postfix_expression632_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_19_in_postfix_expression656  */
static	ANTLR3_BITWORD FOLLOW_19_in_postfix_expression656_bits[]	= { ANTLR3_UINT64_LIT(0x00000000240A8350) };
static  ANTLR3_BITSET_LIST FOLLOW_19_in_postfix_expression656	= { FOLLOW_19_in_postfix_expression656_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_argument_expression_list_in_postfix_expression660  */
static	ANTLR3_BITWORD FOLLOW_argument_expression_list_in_postfix_expression660_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000100000) };
static  ANTLR3_BITSET_LIST FOLLOW_argument_expression_list_in_postfix_expression660	= { FOLLOW_argument_expression_list_in_postfix_expression660_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_20_in_postfix_expression662  */
static	ANTLR3_BITWORD FOLLOW_20_in_postfix_expression662_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004080002) };
static  ANTLR3_BITSET_LIST FOLLOW_20_in_postfix_expression662	= { FOLLOW_20_in_postfix_expression662_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_assignment_expression_in_argument_expression_list720  */
static	ANTLR3_BITWORD FOLLOW_assignment_expression_in_argument_expression_list720_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400002) };
static  ANTLR3_BITSET_LIST FOLLOW_assignment_expression_in_argument_expression_list720	= { FOLLOW_assignment_expression_in_argument_expression_list720_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_22_in_argument_expression_list740  */
static	ANTLR3_BITWORD FOLLOW_22_in_argument_expression_list740_bits[]	= { ANTLR3_UINT64_LIT(0x00000000240A8350) };
static  ANTLR3_BITSET_LIST FOLLOW_22_in_argument_expression_list740	= { FOLLOW_22_in_argument_expression_list740_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_assignment_expression_in_argument_expression_list746  */
static	ANTLR3_BITWORD FOLLOW_assignment_expression_in_argument_expression_list746_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400002) };
static  ANTLR3_BITSET_LIST FOLLOW_assignment_expression_in_argument_expression_list746	= { FOLLOW_assignment_expression_in_argument_expression_list746_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_primary_expression791  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_primary_expression791_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_primary_expression791	= { FOLLOW_IDENTIFIER_in_primary_expression791_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_atom_in_primary_expression820  */
static	ANTLR3_BITWORD FOLLOW_atom_in_primary_expression820_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_atom_in_primary_expression820	= { FOLLOW_atom_in_primary_expression820_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_19_in_primary_expression830  */
static	ANTLR3_BITWORD FOLLOW_19_in_primary_expression830_bits[]	= { ANTLR3_UINT64_LIT(0x00000000240A8350) };
static  ANTLR3_BITSET_LIST FOLLOW_19_in_primary_expression830	= { FOLLOW_19_in_primary_expression830_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_assignment_expression_in_primary_expression836  */
static	ANTLR3_BITWORD FOLLOW_assignment_expression_in_primary_expression836_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000100000) };
static  ANTLR3_BITSET_LIST FOLLOW_assignment_expression_in_primary_expression836	= { FOLLOW_assignment_expression_in_primary_expression836_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_20_in_primary_expression840  */
static	ANTLR3_BITWORD FOLLOW_20_in_primary_expression840_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_20_in_primary_expression840	= { FOLLOW_20_in_primary_expression840_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_assignment_expression_in_constant_expression_list926  */
static	ANTLR3_BITWORD FOLLOW_assignment_expression_in_constant_expression_list926_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400002) };
static  ANTLR3_BITSET_LIST FOLLOW_assignment_expression_in_constant_expression_list926	= { FOLLOW_assignment_expression_in_constant_expression_list926_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RANGE_LITERAL_in_constant_expression_list960  */
static	ANTLR3_BITWORD FOLLOW_RANGE_LITERAL_in_constant_expression_list960_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400002) };
static  ANTLR3_BITSET_LIST FOLLOW_RANGE_LITERAL_in_constant_expression_list960	= { FOLLOW_RANGE_LITERAL_in_constant_expression_list960_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_22_in_constant_expression_list986  */
static	ANTLR3_BITWORD FOLLOW_22_in_constant_expression_list986_bits[]	= { ANTLR3_UINT64_LIT(0x00000000240AA350) };
static  ANTLR3_BITSET_LIST FOLLOW_22_in_constant_expression_list986	= { FOLLOW_22_in_constant_expression_list986_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_assignment_expression_in_constant_expression_list993  */
static	ANTLR3_BITWORD FOLLOW_assignment_expression_in_constant_expression_list993_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400002) };
static  ANTLR3_BITSET_LIST FOLLOW_assignment_expression_in_constant_expression_list993	= { FOLLOW_assignment_expression_in_constant_expression_list993_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RANGE_LITERAL_in_constant_expression_list1033  */
static	ANTLR3_BITWORD FOLLOW_RANGE_LITERAL_in_constant_expression_list1033_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400002) };
static  ANTLR3_BITSET_LIST FOLLOW_RANGE_LITERAL_in_constant_expression_list1033	= { FOLLOW_RANGE_LITERAL_in_constant_expression_list1033_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constant_in_atom1117  */
static	ANTLR3_BITWORD FOLLOW_constant_in_atom1117_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constant_in_atom1117	= { FOLLOW_constant_in_atom1117_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_26_in_atom1123  */
static	ANTLR3_BITWORD FOLLOW_26_in_atom1123_bits[]	= { ANTLR3_UINT64_LIT(0x000000002C0AA350) };
static  ANTLR3_BITSET_LIST FOLLOW_26_in_atom1123	= { FOLLOW_26_in_atom1123_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constant_expression_list_in_atom1140  */
static	ANTLR3_BITWORD FOLLOW_constant_expression_list_in_atom1140_bits[]	= { ANTLR3_UINT64_LIT(0x0000000008000000) };
static  ANTLR3_BITSET_LIST FOLLOW_constant_expression_list_in_atom1140	= { FOLLOW_constant_expression_list_in_atom1140_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_27_in_atom1159  */
static	ANTLR3_BITWORD FOLLOW_27_in_atom1159_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_27_in_atom1159	= { FOLLOW_27_in_atom1159_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_29_in_atom1167  */
static	ANTLR3_BITWORD FOLLOW_29_in_atom1167_bits[]	= { ANTLR3_UINT64_LIT(0x00000000640AA350) };
static  ANTLR3_BITSET_LIST FOLLOW_29_in_atom1167	= { FOLLOW_29_in_atom1167_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constant_expression_list_in_atom1176  */
static	ANTLR3_BITWORD FOLLOW_constant_expression_list_in_atom1176_bits[]	= { ANTLR3_UINT64_LIT(0x0000000040000000) };
static  ANTLR3_BITSET_LIST FOLLOW_constant_expression_list_in_atom1176	= { FOLLOW_constant_expression_list_in_atom1176_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_30_in_atom1184  */
static	ANTLR3_BITWORD FOLLOW_30_in_atom1184_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_30_in_atom1184	= { FOLLOW_30_in_atom1184_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DECIMAL_LITERAL_in_constant1222  */
static	ANTLR3_BITWORD FOLLOW_DECIMAL_LITERAL_in_constant1222_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DECIMAL_LITERAL_in_constant1222	= { FOLLOW_DECIMAL_LITERAL_in_constant1222_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CHARACTER_LITERAL_in_constant1246  */
static	ANTLR3_BITWORD FOLLOW_CHARACTER_LITERAL_in_constant1246_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CHARACTER_LITERAL_in_constant1246	= { FOLLOW_CHARACTER_LITERAL_in_constant1246_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_LITERAL_in_constant1271  */
static	ANTLR3_BITWORD FOLLOW_STRING_LITERAL_in_constant1271_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_LITERAL_in_constant1271	= { FOLLOW_STRING_LITERAL_in_constant1271_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FLOATING_POINT_LITERAL_in_constant1296  */
static	ANTLR3_BITWORD FOLLOW_FLOATING_POINT_LITERAL_in_constant1296_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_FLOATING_POINT_LITERAL_in_constant1296	= { FOLLOW_FLOATING_POINT_LITERAL_in_constant1296_bits, 1	};


/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start prog
 * /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:47:3: prog : (a= query )+ ;
 */
static void
prog(ppqlParser ctx)
{
    /* Initialize rule variables
     */

    {
        // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:49:3: ( (a= query )+ )
        // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:49:5: (a= query )+
        {
            // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:49:6: (a= query )+
            {
                int cnt1=0;

                for (;;)
                {
                    int alt1=2;
            	switch ( LA(1) )
            	{
            	case CHARACTER_LITERAL:
            	case DECIMAL_LITERAL:
            	case FLOATING_POINT_LITERAL:
            	case IDENTIFIER:
            	case NEWLINE:
            	case STRING_LITERAL:
            	case 17:
            	case 19:
            	case 26:
            	case 29:
            		{
            			alt1=1;
            		}
            	    break;

            	}

            	switch (alt1)
            	{
            	    case 1:
            	        // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:49:6: a= query
            	        {
            	            FOLLOWPUSH(FOLLOW_query_in_prog62);
            	            query(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleprogEx;
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt1 >= 1 )
            		{
            		    goto loop1;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto ruleprogEx;
            	}
            	cnt1++;
                }
                loop1: ;	/* Jump to here if this rule does not match */
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleprogEx; /* Prevent compiler warnings */
    ruleprogEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end prog */

/**
 * $ANTLR start query
 * /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:53:1: query : (a= assignment_expression )? NEWLINE ;
 */
static void
query(ppqlParser ctx)
{
    pqlsymbol * a;
    #undef	RETURN_TYPE_a
    #define	RETURN_TYPE_a pqlsymbol *

    /* Initialize rule variables
     */

    {
        // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:54:3: ( (a= assignment_expression )? NEWLINE )
        // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:54:5: (a= assignment_expression )? NEWLINE
        {
            // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:54:5: (a= assignment_expression )?
            {
                int alt2=2;
                switch ( LA(1) )
                {
                    case CHARACTER_LITERAL:
                    case DECIMAL_LITERAL:
                    case FLOATING_POINT_LITERAL:
                    case IDENTIFIER:
                    case STRING_LITERAL:
                    case 17:
                    case 19:
                    case 26:
                    case 29:
                    	{
                    		alt2=1;
                    	}
                        break;
                }

                switch (alt2)
                {
            	case 1:
            	    // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:54:6: a= assignment_expression
            	    {
            	        FOLLOWPUSH(FOLLOW_assignment_expression_in_query85);
            	        a=assignment_expression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulequeryEx;
            	        }


            	        {

            	                  pqlsymbol *  result = new pqlsymbol();
            	                   
            	                   if( a
            	            ->is_symbol() )
            	                  {
            	                      std::map<std::string, pqlsymbol * >::const_iterator iter = symbol_table.find( a
            	            ->get_symbolname() );
            	                      if (iter == symbol_table.end())
            	                      {
            	                        // not found
            	                        result = new pqlsymbol(ERROR, "symbol undefined, which shoudln't ever happen");
            	                        delete a
            	            ;
            	                      }
            	                      else
            	                      {
            	                         //probably need a copy of the value here. 
            	                        result = ( (*iter).second->get_value_as_new_pqlsymbol() );
            	                        cout << a
            	            ->get_symbolname() << " = " << result->value_to_string() << endl;
            	                        delete a
            	            ;
            	                      }
            	                      /*cout << "Query result " << result->value_to_string() <<  endl;*/
            	                      query_results.push_back( result ); 
            	                  }
            	                  else
            	                  {
            	                     /*cout << "Query result " << a
            	            ->value_to_string() <<  endl;*/
            	                     cout << a
            	            ->value_to_string() << endl;
            	                     query_results.push_back( a
            	             ); 
            	                     delete result;
            	                  } 
            	                
            	        }


            	    }
            	    break;

                }
            }

             MATCHT(NEWLINE, &FOLLOW_NEWLINE_in_query106);
            if  (HASEXCEPTION())
            {
                goto rulequeryEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulequeryEx; /* Prevent compiler warnings */
    rulequeryEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end query */

/**
 * $ANTLR start assignment_expression
 * /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:100:1: assignment_expression returns [pqlsymbol * result] : (id= IDENTIFIER '=' a= assignment_expression |a= not_expression );
 */
static pqlsymbol *
assignment_expression(ppqlParser ctx)
{
    pqlsymbol * result;


    pANTLR3_COMMON_TOKEN    id;
    pqlsymbol * a;
    #undef	RETURN_TYPE_a
    #define	RETURN_TYPE_a pqlsymbol *

    /* Initialize rule variables
     */

    id       = NULL;

    {
        {
            //  /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:102:5: (id= IDENTIFIER '=' a= assignment_expression |a= not_expression )

            ANTLR3_UINT32 alt3;

            alt3=2;

            switch ( LA(1) )
            {
            case IDENTIFIER:
            	{
            		switch ( LA(2) )
            		{
            		case 24:
            			{
            				alt3=1;
            			}
            		    break;
            		case NEWLINE:
            		case 18:
            		case 19:
            		case 20:
            		case 21:
            		case 22:
            		case 23:
            		case 25:
            		case 26:
            		case 27:
            		case 28:
            		case 30:
            			{
            				alt3=2;
            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 3;
            		    EXCEPTION->state        = 1;


            		    goto ruleassignment_expressionEx;

            		}

            	}
                break;
            case CHARACTER_LITERAL:
            case DECIMAL_LITERAL:
            case FLOATING_POINT_LITERAL:
            case STRING_LITERAL:
            case 17:
            case 19:
            case 26:
            case 29:
            	{
            		alt3=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 3;
                EXCEPTION->state        = 0;


                goto ruleassignment_expressionEx;

            }

            switch (alt3)
            {
        	case 1:
        	    // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:102:7: id= IDENTIFIER '=' a= assignment_expression
        	    {
        	        id = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_assignment_expression142);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleassignment_expressionEx;
        	        }


        	         MATCHT(24, &FOLLOW_24_in_assignment_expression144);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleassignment_expressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_assignment_expression_in_assignment_expression148);
        	        a=assignment_expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleassignment_expressionEx;
        	        }


        	        {

        	                 /*cout <<  pANTLR3_COMMON_TOKEN_to_string(id) << "=" << 
        	            a
        	            ->value_to_string() << endl;*/
        	                 /*cout << "setting symbol " << pANTLR3_COMMON_TOKEN_to_string(id) << " to " <<  
        	            a
        	            ->value_to_string() << endl;*/

        	                  //At this point in the code I have two copies of the value. 
        	                  //One is stored in the symbol table and the other returned up the interperter tree. 
        	                  
        	                   if( a
        	            ->is_symbol() )
        	                  {
        	                  
        	                      std::map<std::string, pqlsymbol * >::const_iterator iter = symbol_table.find( a
        	            ->get_symbolname() );
        	                      if (iter == symbol_table.end())
        	                      {
        	                        // not found
        	                        //notFound = true;
        	                        result= new pqlsymbol(ERROR, "symbol undefined");

        	                      }
        	                      else
        	                      {
        	                         //probably need a copy of the value here. 
        	                        result= ( (*iter).second->get_value_as_new_pqlsymbol() );
        	                       
        	                      }
        	                  }
        	                  
        	                  else
        	                  {
        	                    //check if the symbol is a constant before we do any work. 
        	                    
        	                     std::map<std::string, bool >::const_iterator iter1 = constant_table.find( pANTLR3_COMMON_TOKEN_to_string(id) );
        	                     if (iter1 == constant_table.end())
        	                     {
        	                      ::symbol_table[pANTLR3_COMMON_TOKEN_to_string(id)]= 
        	            a
        	            ->get_value_as_new_pqlsymbol();
        	                      result= new pqlsymbol(SYMBOL, pANTLR3_COMMON_TOKEN_to_string(id) );

        	                     }
        	                    else{
        	                    result= new pqlsymbol(ERROR, "Can not assign a value to a static varible");

        	                    }
        	                   
        	                    
        	                  }
        	                  delete a
        	            ;
        	                  
        	                
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:147:7: a= not_expression
        	    {
        	        FOLLOWPUSH(FOLLOW_not_expression_in_assignment_expression173);
        	        a=not_expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleassignment_expressionEx;
        	        }


        	        {

        	                    result= 
        	            a
        	            ;

        	                  
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleassignment_expressionEx; /* Prevent compiler warnings */
    ruleassignment_expressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return result;
}
/* $ANTLR end assignment_expression */

/**
 * $ANTLR start not_expression
 * /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:162:1: not_expression returns [pqlsymbol *result] : ( '!' )? a= difference_expression ;
 */
static pqlsymbol *
not_expression(ppqlParser ctx)
{
    pqlsymbol * result;


    pqlsymbol * a;
    #undef	RETURN_TYPE_a
    #define	RETURN_TYPE_a pqlsymbol *

    /* Initialize rule variables
     */


          bool diffFlag = false;
          bool errorFlag = false;
          set<unsigned int> s1;
        
    {
        // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:170:8: ( ( '!' )? a= difference_expression )
        // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:170:10: ( '!' )? a= difference_expression
        {
            // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:170:10: ( '!' )?
            {
                int alt4=2;
                switch ( LA(1) )
                {
                    case 17:
                    	{
                    		alt4=1;
                    	}
                        break;
                }

                switch (alt4)
                {
            	case 1:
            	    // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:170:11: '!'
            	    {
            	         MATCHT(17, &FOLLOW_17_in_not_expression231);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulenot_expressionEx;
            	        }


            	        {
            	             diffFlag = true; 
            	        }


            	    }
            	    break;

                }
            }

            FOLLOWPUSH(FOLLOW_difference_expression_in_not_expression242);
            a=difference_expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulenot_expressionEx;
            }


            {

                      if (diffFlag == false){
                        result= 
                a
                ;

                      }
                      else{
                        if( a
                ->is_treeset()  ){
                          set<unsigned int> s1 = a
                ->get_treeset();
                           
                          set<unsigned int> sdiff;
                         
                          std::set_difference( all_trees.begin(), all_trees.end(), s1.begin(), s1.end(),  std::inserter( sdiff, sdiff.begin() ) );
                          
                          result= new pqlsymbol(sdiff);

                        }
                        else{
                          result= new pqlsymbol(ERROR, "'Not' is only avaible for a treeset." );

                        }
                      }
                    
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulenot_expressionEx; /* Prevent compiler warnings */
    rulenot_expressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return result;
}
/* $ANTLR end not_expression */

/**
 * $ANTLR start difference_expression
 * /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:193:1: difference_expression returns [pqlsymbol *result] : a= union_expression ( '-' b= union_expression )* ;
 */
static pqlsymbol *
difference_expression(ppqlParser ctx)
{
    pqlsymbol * result;


    pqlsymbol * a;
    #undef	RETURN_TYPE_a
    #define	RETURN_TYPE_a pqlsymbol *

    pqlsymbol * b;
    #undef	RETURN_TYPE_b
    #define	RETURN_TYPE_b pqlsymbol *

    /* Initialize rule variables
     */


          bool diffFlag = false;
          bool errorFlag = false;
          set<unsigned int> s1;
        
    {
        // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:201:8: (a= union_expression ( '-' b= union_expression )* )
        // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:201:10: a= union_expression ( '-' b= union_expression )*
        {
            FOLLOWPUSH(FOLLOW_union_expression_in_difference_expression301);
            a=union_expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledifference_expressionEx;
            }


            {
                 if( a
                ->is_treeset() ){s1 = a
                ->get_treeset();  }
            }


            // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:202:8: ( '-' b= union_expression )*

            for (;;)
            {
                int alt5=2;
                switch ( LA(1) )
                {
                case 23:
                	{
                		alt5=1;
                	}
                    break;

                }

                switch (alt5)
                {
            	case 1:
            	    // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:202:10: '-' b= union_expression
            	    {
            	         MATCHT(23, &FOLLOW_23_in_difference_expression313);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledifference_expressionEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_union_expression_in_difference_expression319);
            	        b=union_expression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledifference_expressionEx;
            	        }


            	        {
            	             diffFlag = true; 
            	        }


            	    }
            	    break;

            	default:
            	    goto loop5;	/* break out of the loop */
            	    break;
                }
            }
            loop5: ; /* Jump out to here if this rule does not match */


            {

                      if (diffFlag == false){
                        result= 
                a
                ;

                      }
                      else{
                        if( a
                ->is_treeset() && b
                ->is_treeset()  ){
                          set<unsigned int> s2 = b
                ->get_treeset();
                           
                          set<unsigned int> diff;
                          
                          std::set_difference( s1.begin(), s1.end(), s2.begin(), s2.end(),
                    	std::inserter( diff, diff.begin() ) );
                           s1 = diff;
                          result= new pqlsymbol(diff);

                        }
                        else{
                          result= new pqlsymbol(ERROR, "'Difference' is currently only avaible between two int vector types." );

                        }
                      }
                    
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruledifference_expressionEx; /* Prevent compiler warnings */
    ruledifference_expressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return result;
}
/* $ANTLR end difference_expression */

/**
 * $ANTLR start union_expression
 * /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:225:1: union_expression returns [pqlsymbol *result] : a= intersection_expression ( '+' b= intersection_expression )* ;
 */
static pqlsymbol *
union_expression(ppqlParser ctx)
{
    pqlsymbol * result;


    pqlsymbol * a;
    #undef	RETURN_TYPE_a
    #define	RETURN_TYPE_a pqlsymbol *

    pqlsymbol * b;
    #undef	RETURN_TYPE_b
    #define	RETURN_TYPE_b pqlsymbol *

    /* Initialize rule variables
     */


          bool orFlag = false;
          bool errorFlag = false;
          set<unsigned int> s1;
        
    {
        // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:233:5: (a= intersection_expression ( '+' b= intersection_expression )* )
        // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:233:7: a= intersection_expression ( '+' b= intersection_expression )*
        {
            FOLLOWPUSH(FOLLOW_intersection_expression_in_union_expression371);
            a=intersection_expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleunion_expressionEx;
            }


            {
                    
                      if( a
                ->is_treeset() ){s1 = a
                ->get_treeset();  }
                      
            }


            // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:235:10: ( '+' b= intersection_expression )*

            for (;;)
            {
                int alt6=2;
                switch ( LA(1) )
                {
                case 21:
                	{
                		alt6=1;
                	}
                    break;

                }

                switch (alt6)
                {
            	case 1:
            	    // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:235:12: '+' b= intersection_expression
            	    {
            	         MATCHT(21, &FOLLOW_21_in_union_expression377);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleunion_expressionEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_intersection_expression_in_union_expression383);
            	        b=intersection_expression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleunion_expressionEx;
            	        }


            	        {

            	                 orFlag = true; 
            	                 if(  b
            	            ->is_treeset()  ){
            	                      /*set<int> s1 = a
            	            ->get_treeset();*/
            	                      set<unsigned int> s2 = b
            	            ->get_treeset();
            	                      set<unsigned int> uni;
            	                      std::set_union( s1.begin(), s1.end(), s2.begin(), s2.end(),
            	                	std::inserter( uni, uni.begin() ) );
            	                       s1 = uni;
            	                       
            	                      result= new pqlsymbol(uni);

            	                 }
            	                 else{errorFlag = true;}
            	                    
            	                
            	        }


            	    }
            	    break;

            	default:
            	    goto loop6;	/* break out of the loop */
            	    break;
                }
            }
            loop6: ; /* Jump out to here if this rule does not match */


            {

                      if (orFlag == false){
                        result= 
                a
                ;

                      }
                      else if (errorFlag){
                          result= new pqlsymbol(ERROR, "'Union' is currently only avaible between two int vector types." );

                      }
                    
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleunion_expressionEx; /* Prevent compiler warnings */
    ruleunion_expressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return result;
}
/* $ANTLR end union_expression */

/**
 * $ANTLR start intersection_expression
 * /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:261:1: intersection_expression returns [pqlsymbol *result] : a= equality_expression ( '^' b= equality_expression )* ;
 */
static pqlsymbol *
intersection_expression(ppqlParser ctx)
{
    pqlsymbol * result;


    pqlsymbol * a;
    #undef	RETURN_TYPE_a
    #define	RETURN_TYPE_a pqlsymbol *

    pqlsymbol * b;
    #undef	RETURN_TYPE_b
    #define	RETURN_TYPE_b pqlsymbol *

    /* Initialize rule variables
     */


          bool andFlag = false;
          bool errorFlag = false;
          set<unsigned int> s1;
        
    {
        // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:269:5: (a= equality_expression ( '^' b= equality_expression )* )
        // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:269:7: a= equality_expression ( '^' b= equality_expression )*
        {
            FOLLOWPUSH(FOLLOW_equality_expression_in_intersection_expression440);
            a=equality_expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleintersection_expressionEx;
            }


            {
                if( a
                ->is_treeset() ){s1 = a
                ->get_treeset();  }
            }


            // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:270:6: ( '^' b= equality_expression )*

            for (;;)
            {
                int alt7=2;
                switch ( LA(1) )
                {
                case 28:
                	{
                		alt7=1;
                	}
                    break;

                }

                switch (alt7)
                {
            	case 1:
            	    // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:270:7: '^' b= equality_expression
            	    {
            	         MATCHT(28, &FOLLOW_28_in_intersection_expression450);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleintersection_expressionEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_equality_expression_in_intersection_expression456);
            	        b=equality_expression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleintersection_expressionEx;
            	        }


            	        {

            	                      andFlag = true;
            	                      if( a
            	            ->is_treeset() && b
            	            ->is_treeset()  ){
            	                      
            	                      set<unsigned int> s2 = b
            	            ->get_treeset();
            	                       
            	                      set<unsigned int> intersection;
            	                      
            	                      std::set_intersection( s1.begin(), s1.end(), s2.begin(), s2.end(),
            	                	std::inserter( intersection, intersection.begin() ) );
            	                      
            	                      s1 = intersection;
            	                                
            	                      result= new pqlsymbol(intersection);

            	                    }
            	                    else{
            	                      errorFlag = true;
            	                    }
            	                    
            	                
            	        }


            	    }
            	    break;

            	default:
            	    goto loop7;	/* break out of the loop */
            	    break;
                }
            }
            loop7: ; /* Jump out to here if this rule does not match */


            {

                      if (andFlag == false){
                        result= 
                a
                ;

                      }
                      else if (errorFlag){
                        result= new pqlsymbol(ERROR, "'intersection' is currently only avaible between two treesets." );

                      }
                    
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleintersection_expressionEx; /* Prevent compiler warnings */
    ruleintersection_expressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return result;
}
/* $ANTLR end intersection_expression */

/**
 * $ANTLR start equality_expression
 * /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:302:1: equality_expression returns [pqlsymbol * result] : a= postfix_expression ( ( '==' | '!=' ) b= postfix_expression )* ;
 */
static pqlsymbol *
equality_expression(ppqlParser ctx)
{
    pqlsymbol * result;


    pqlsymbol * a;
    #undef	RETURN_TYPE_a
    #define	RETURN_TYPE_a pqlsymbol *

    pqlsymbol * b;
    #undef	RETURN_TYPE_b
    #define	RETURN_TYPE_b pqlsymbol *

    /* Initialize rule variables
     */


        bool equalityFlag = false;
        bool eqFlag = true; 
      
    {
        // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:310:5: (a= postfix_expression ( ( '==' | '!=' ) b= postfix_expression )* )
        // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:310:7: a= postfix_expression ( ( '==' | '!=' ) b= postfix_expression )*
        {
            FOLLOWPUSH(FOLLOW_postfix_expression_in_equality_expression513);
            a=postfix_expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleequality_expressionEx;
            }


            // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:310:30: ( ( '==' | '!=' ) b= postfix_expression )*

            for (;;)
            {
                int alt9=2;
                switch ( LA(1) )
                {
                case 18:
                case 25:
                	{
                		alt9=1;
                	}
                    break;

                }

                switch (alt9)
                {
            	case 1:
            	    // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:310:31: ( '==' | '!=' ) b= postfix_expression
            	    {
            	        // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:310:31: ( '==' | '!=' )
            	        {
            	            int alt8=2;
            	            switch ( LA(1) )
            	            {
            	            case 25:
            	            	{
            	            		alt8=1;
            	            	}
            	                break;
            	            case 18:
            	            	{
            	            		alt8=2;
            	            	}
            	                break;

            	            default:
            	                CONSTRUCTEX();
            	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	                EXCEPTION->message      = (void *)"";
            	                EXCEPTION->decisionNum  = 8;
            	                EXCEPTION->state        = 0;


            	                goto ruleequality_expressionEx;

            	            }

            	            switch (alt8)
            	            {
            	        	case 1:
            	        	    // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:310:32: '=='
            	        	    {
            	        	         MATCHT(25, &FOLLOW_25_in_equality_expression517);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleequality_expressionEx;
            	        	        }


            	        	        {
            	        	            eqFlag = true; equalityFlag = true;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:310:75: '!='
            	        	    {
            	        	         MATCHT(18, &FOLLOW_18_in_equality_expression521);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleequality_expressionEx;
            	        	        }


            	        	        {
            	        	            eqFlag = false; equalityFlag = true;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        FOLLOWPUSH(FOLLOW_postfix_expression_in_equality_expression530);
            	        b=postfix_expression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleequality_expressionEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop9;	/* break out of the loop */
            	    break;
                }
            }
            loop9: ; /* Jump out to here if this rule does not match */


            {

                        if (equalityFlag)
                        {
                           if(eqFlag)
                           {
                             if( a
                 == b
                 )
                             {
                               result= new  pqlsymbol( true);

                             }
                             else
                             {
                                result= new pqlsymbol( false);

                             }
                           }
                           else
                           {
                              if( a
                 != b
                 )
                              {
                                 result= new pqlsymbol( true);

                              }
                              else
                              {
                                result= new pqlsymbol( false);

                              }
                           }
                         }
                         else
                         {
                           result= 
                a
                ;

                         }
                      
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleequality_expressionEx; /* Prevent compiler warnings */
    ruleequality_expressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return result;
}
/* $ANTLR end equality_expression */

/**
 * $ANTLR start postfix_expression
 * /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:344:1: postfix_expression returns [pqlsymbol * result] : a= primary_expression ( '[' b= assignment_expression ']' | '(' ')' | '(' c= argument_expression_list ')' )* ;
 */
static pqlsymbol *
postfix_expression(ppqlParser ctx)
{
    pqlsymbol * result;


    pqlsymbol * a;
    #undef	RETURN_TYPE_a
    #define	RETURN_TYPE_a pqlsymbol *

    pqlsymbol * b;
    #undef	RETURN_TYPE_b
    #define	RETURN_TYPE_b pqlsymbol *

    vector<pqlsymbol * > c;
    #undef	RETURN_TYPE_c
    #define	RETURN_TYPE_c vector<pqlsymbol * >

    /* Initialize rule variables
     */


          bool arrayorfunct = false;
      
    {
        // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:350:5: (a= primary_expression ( '[' b= assignment_expression ']' | '(' ')' | '(' c= argument_expression_list ')' )* )
        // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:350:8: a= primary_expression ( '[' b= assignment_expression ']' | '(' ')' | '(' c= argument_expression_list ')' )*
        {
            FOLLOWPUSH(FOLLOW_primary_expression_in_postfix_expression586);
            a=primary_expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulepostfix_expressionEx;
            }


            {

                    /*cout << "In postfix_expression a = " <<  a
                ->value_to_string() << endl; */
                    
            }


            // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:353:5: ( '[' b= assignment_expression ']' | '(' ')' | '(' c= argument_expression_list ')' )*

            for (;;)
            {
                int alt10=4;
                switch ( LA(1) )
                {
                case 26:
                	{
                		alt10=1;
                	}
                    break;
                case 19:
                	{
                		switch ( LA(2) )
                		{
                		case 20:
                			{
                				alt10=2;
                			}
                		    break;
                		case CHARACTER_LITERAL:
                		case DECIMAL_LITERAL:
                		case FLOATING_POINT_LITERAL:
                		case IDENTIFIER:
                		case STRING_LITERAL:
                		case 17:
                		case 19:
                		case 26:
                		case 29:
                			{
                				alt10=3;
                			}
                		    break;

                		}

                	}
                    break;

                }

                switch (alt10)
                {
            	case 1:
            	    // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:353:8: '[' b= assignment_expression ']'
            	    {
            	         MATCHT(26, &FOLLOW_26_in_postfix_expression597);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepostfix_expressionEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_assignment_expression_in_postfix_expression603);
            	        b=assignment_expression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepostfix_expressionEx;
            	        }


            	         MATCHT(27, &FOLLOW_27_in_postfix_expression605);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepostfix_expressionEx;
            	        }


            	        {

            	                     // you didn't apply [] to a vector
            	                     if (! a
            	            ->is_vect() )
            	                     {
            	                        //cout << "Oh, it's not an vect that you are indexing.. that's really bad" << endl;
            	                        result= new pqlsymbol(ERROR, "Tried to index a vector without using an int");

            	                     }
            	                     
            	                     //if you don't give [] an int
            	                     else if (! b
            	            ->is_int() ) 
            	                     {
            	                        //cout << "Oh, it's not an Int.. that's really bad" << endl;
            	                        result= new pqlsymbol(ERROR, "Tried to index a vector without using an int");

            	                     }
            	                      
            	                     // if you give [] an int, but out of range 
            	                     else if (! (a
            	            ->get_vect_size() >= b
            	            ->get_int() ) )
            	                     {
            	                       //cout << "index out of range for vector" << endl;
            	                       result= new pqlsymbol(ERROR, "index out of range");

            	                     }
            	                      
            	                     else if (! ( b
            	            ->get_int() >= 0) )
            	                     {
            	                       //cout << "index out of range for vector, we don't support negative numbers. " << endl;
            	                       result= new pqlsymbol(ERROR, "index out of range");

            	                     } 
            	                     // you gave it all correct things, so now lets return your symbol. 
            	                     else
            	                     {
            	                        result= 
            	            a
            	            ->get_list_symbol(b
            	            ->get_int() );

            	                     }
            	                     arrayorfunct = true;
            	                     
            	                  
            	        }


            	    }
            	    break;
            	case 2:
            	    // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:390:7: '(' ')'
            	    {
            	         MATCHT(19, &FOLLOW_19_in_postfix_expression630);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepostfix_expressionEx;
            	        }


            	         MATCHT(20, &FOLLOW_20_in_postfix_expression632);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepostfix_expressionEx;
            	        }


            	        {

            	                    arrayorfunct = true;
            	                    /*cout << "testing if " << a
            	            ->get_string()<< " is a function" <<endl;*/
            	                    std::map<std::string, vfptr>::const_iterator iter = voidFunctMap.find(a
            	            ->get_string());
            	                    if (iter == voidFunctMap.end())
            	                    {
            	                    // not found
            	                      result= new pqlsymbol(ERROR, "not a legal function");

            	                      //cout << "not a legal function" << endl;
            	                    }
            	                    
            	                    else
            	                    {
            	                      result= (*iter).second();

            	                    }
            	                    
            	                   // delete a
            	            ;  
            	                      
            	                  
            	        }


            	    }
            	    break;
            	case 3:
            	    // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:411:7: '(' c= argument_expression_list ')'
            	    {
            	         MATCHT(19, &FOLLOW_19_in_postfix_expression656);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepostfix_expressionEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_argument_expression_list_in_postfix_expression660);
            	        c=argument_expression_list(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepostfix_expressionEx;
            	        }


            	         MATCHT(20, &FOLLOW_20_in_postfix_expression662);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepostfix_expressionEx;
            	        }


            	        {

            	                    arrayorfunct = true;
            	                    /*cout << "testing if " << a
            	            ->get_string()<< " is a function" <<endl;*/
            	                    std::map<std::string, afptr>::const_iterator iter = argFunctMap.find(a
            	            ->get_string());
            	                    if (iter == argFunctMap.end())
            	                    {
            	                    // not found         
            	                    //cout << "not a legal function" << endl;
            	                    result= new pqlsymbol(ERROR, "not a legal function");

            	                    }
            	                    else
            	                    {
            	                      //Gotta have a value copy thing here. 
            	                      if(a
            	            ->get_string()=="show"){
            	                      	cout << "We have show function!\n";
            	                      	}
            	                     std::map<std::string, vector<vector<int>>>::iterator it = argMap.find(a
            	            ->get_string());
            	                     if(it==argMap.end()){ 
            	                      result=  (*iter).second(
            	            c
            	            ) ;

            	                      while(!c
            	            .empty()){
            	                              delete c
            	            .back();
            	                              c
            	            .pop_back();
            	                      }
            	                      }
            	                     else{
            	                     	cout << "we found the argument in argMap!!!\n";
            	                     	result= u_template(
            	            c
            	            , a
            	            ->get_string());

            	                     	 
            	                     	 while(!c
            	            .empty()){
            	                              	delete c
            	            .back();
            	                              	c
            	            .pop_back();
            	                      		}
            	                     	} 
            	                    }
            	                
            	        }


            	    }
            	    break;

            	default:
            	    goto loop10;	/* break out of the loop */
            	    break;
                }
            }
            loop10: ; /* Jump out to here if this rule does not match */


            {

                      if (arrayorfunct == false)
                      {
                        result= 
                a
                ;

                      }
                    
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulepostfix_expressionEx; /* Prevent compiler warnings */
    rulepostfix_expressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return result;
}
/* $ANTLR end postfix_expression */

/**
 * $ANTLR start argument_expression_list
 * /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:457:1: argument_expression_list returns [vector<pqlsymbol * > result] : a= assignment_expression ( ',' b= assignment_expression )* ;
 */
static vector<pqlsymbol * >
argument_expression_list(ppqlParser ctx)
{
    vector<pqlsymbol * > result;


    pqlsymbol * a;
    #undef	RETURN_TYPE_a
    #define	RETURN_TYPE_a pqlsymbol *

    pqlsymbol * b;
    #undef	RETURN_TYPE_b
    #define	RETURN_TYPE_b pqlsymbol *

    /* Initialize rule variables
     */

    {
        // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:459:5: (a= assignment_expression ( ',' b= assignment_expression )* )
        // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:459:9: a= assignment_expression ( ',' b= assignment_expression )*
        {
            FOLLOWPUSH(FOLLOW_assignment_expression_in_argument_expression_list720);
            a=assignment_expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleargument_expression_listEx;
            }


            {

                      result.push_back(a
                ); 
                    
            }


            // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:464:5: ( ',' b= assignment_expression )*

            for (;;)
            {
                int alt11=2;
                switch ( LA(1) )
                {
                case 22:
                	{
                		alt11=1;
                	}
                    break;

                }

                switch (alt11)
                {
            	case 1:
            	    // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:464:6: ',' b= assignment_expression
            	    {
            	         MATCHT(22, &FOLLOW_22_in_argument_expression_list740);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleargument_expression_listEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_assignment_expression_in_argument_expression_list746);
            	        b=assignment_expression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleargument_expression_listEx;
            	        }


            	        {

            	                    result.push_back(b
            	            ); 
            	                  
            	        }


            	    }
            	    break;

            	default:
            	    goto loop11;	/* break out of the loop */
            	    break;
                }
            }
            loop11: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleargument_expression_listEx; /* Prevent compiler warnings */
    ruleargument_expression_listEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return result;
}
/* $ANTLR end argument_expression_list */

/**
 * $ANTLR start primary_expression
 * /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:471:1: primary_expression returns [pqlsymbol * result] : (id= IDENTIFIER |a= atom | '(' a= assignment_expression ')' );
 */
static pqlsymbol *
primary_expression(ppqlParser ctx)
{
    pqlsymbol * result;


    pANTLR3_COMMON_TOKEN    id;
    pqlsymbol * a;
    #undef	RETURN_TYPE_a
    #define	RETURN_TYPE_a pqlsymbol *

    /* Initialize rule variables
     */

    id       = NULL;

    {
        {
            //  /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:473:5: (id= IDENTIFIER |a= atom | '(' a= assignment_expression ')' )

            ANTLR3_UINT32 alt12;

            alt12=3;

            switch ( LA(1) )
            {
            case IDENTIFIER:
            	{
            		alt12=1;
            	}
                break;
            case CHARACTER_LITERAL:
            case DECIMAL_LITERAL:
            case FLOATING_POINT_LITERAL:
            case STRING_LITERAL:
            case 26:
            case 29:
            	{
            		alt12=2;
            	}
                break;
            case 19:
            	{
            		alt12=3;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 12;
                EXCEPTION->state        = 0;


                goto ruleprimary_expressionEx;

            }

            switch (alt12)
            {
        	case 1:
        	    // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:473:7: id= IDENTIFIER
        	    {
        	        id = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_primary_expression791);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleprimary_expressionEx;
        	        }


        	        {

        	                      std::map<std::string, pqlsymbol * >::const_iterator iter1 = symbol_table.find( pANTLR3_COMMON_TOKEN_string_lit_to_string( id)  );
        	                      if (iter1 == symbol_table.end())
        	                     {
        	                        // not found
        	                        // TODO: I should check if it's a function name, and if so pass up a function type.
        	                        
        	            result= new pqlsymbol(pANTLR3_COMMON_TOKEN_string_lit_to_string( id) );

        	                        //result= new pqlsymbol(ERROR, "Varible undefined.");

        	                     }
        	                     else
        	                     {
        	                         //probably need a copy of the value here. 
        	                         result= ( (*iter1).second->get_value_as_new_pqlsymbol() );

        	                      }
        	                  

        	                    /*
        	                    std::map<std::string, pqlsymbol * >::const_iterator iter = symbol_table.find(pANTLR3_COMMON_TOKEN_to_string(id));
        	                    if (iter == symbol_table.end())
        	                    {
        	                    // not found
        	                      
        	            result= new pqlsymbol(ERROR, "symbol undefined");

        	                     }
        	                    else
        	                    {
        	                    //probably need a copy of the value here. 
        	                      result= ( (*iter).second->get_value_as_new_pqlsymbol() );

        	                    }
        	                   */
        	                
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:506:7: a= atom
        	    {
        	        FOLLOWPUSH(FOLLOW_atom_in_primary_expression820);
        	        a=atom(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleprimary_expressionEx;
        	        }


        	        {
        	            result= 
        	            a
        	            ;

        	        }


        	    }
        	    break;
        	case 3:
        	    // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:507:7: '(' a= assignment_expression ')'
        	    {
        	         MATCHT(19, &FOLLOW_19_in_primary_expression830);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleprimary_expressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_assignment_expression_in_primary_expression836);
        	        a=assignment_expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleprimary_expressionEx;
        	        }


        	        {
        	            result= 
        	            a
        	            ;

        	        }


        	         MATCHT(20, &FOLLOW_20_in_primary_expression840);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleprimary_expressionEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleprimary_expressionEx; /* Prevent compiler warnings */
    ruleprimary_expressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return result;
}
/* $ANTLR end primary_expression */

/**
 * $ANTLR start constant_expression_list
 * /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:517:1: constant_expression_list returns [pqlsymbol * result] : (a= assignment_expression |ra= RANGE_LITERAL ) ( ',' (b= assignment_expression |rb= RANGE_LITERAL ) )* ;
 */
static pqlsymbol *
constant_expression_list(ppqlParser ctx)
{
    pqlsymbol * result;


    pANTLR3_COMMON_TOKEN    ra;
    pANTLR3_COMMON_TOKEN    rb;
    pqlsymbol * a;
    #undef	RETURN_TYPE_a
    #define	RETURN_TYPE_a pqlsymbol *

    pqlsymbol * b;
    #undef	RETURN_TYPE_b
    #define	RETURN_TYPE_b pqlsymbol *

    /* Initialize rule variables
     */


          bool errored = false;
          vector <pqlsymbol * > thelist;
      
    ra       = NULL;
    rb       = NULL;

    {
        // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:524:5: ( (a= assignment_expression |ra= RANGE_LITERAL ) ( ',' (b= assignment_expression |rb= RANGE_LITERAL ) )* )
        // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:524:9: (a= assignment_expression |ra= RANGE_LITERAL ) ( ',' (b= assignment_expression |rb= RANGE_LITERAL ) )*
        {
            // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:524:9: (a= assignment_expression |ra= RANGE_LITERAL )
            {
                int alt13=2;
                switch ( LA(1) )
                {
                case CHARACTER_LITERAL:
                case DECIMAL_LITERAL:
                case FLOATING_POINT_LITERAL:
                case IDENTIFIER:
                case STRING_LITERAL:
                case 17:
                case 19:
                case 26:
                case 29:
                	{
                		alt13=1;
                	}
                    break;
                case RANGE_LITERAL:
                	{
                		alt13=2;
                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 13;
                    EXCEPTION->state        = 0;


                    goto ruleconstant_expression_listEx;

                }

                switch (alt13)
                {
            	case 1:
            	    // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:525:11: a= assignment_expression
            	    {
            	        FOLLOWPUSH(FOLLOW_assignment_expression_in_constant_expression_list926);
            	        a=assignment_expression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleconstant_expression_listEx;
            	        }


            	        {
            	             thelist.push_back(a
            	            ); 
            	        }


            	    }
            	    break;
            	case 2:
            	    // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:527:13: ra= RANGE_LITERAL
            	    {
            	        ra = (pANTLR3_COMMON_TOKEN) MATCHT(RANGE_LITERAL, &FOLLOW_RANGE_LITERAL_in_constant_expression_list960);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleconstant_expression_listEx;
            	        }


            	        {
            	             
            	                            vector<int> range = pANTLR3_COMMON_TOKEN_to_intvect(ra);
            	                            for(int i = 0; i < range.size(); i++ ){
            	                              thelist.push_back(new pqlsymbol(range[i]));
            	                            } 
            	                        
            	        }


            	    }
            	    break;

                }
            }

            // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:535:9: ( ',' (b= assignment_expression |rb= RANGE_LITERAL ) )*

            for (;;)
            {
                int alt15=2;
                switch ( LA(1) )
                {
                case 22:
                	{
                		alt15=1;
                	}
                    break;

                }

                switch (alt15)
                {
            	case 1:
            	    // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:535:10: ',' (b= assignment_expression |rb= RANGE_LITERAL )
            	    {
            	         MATCHT(22, &FOLLOW_22_in_constant_expression_list986);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleconstant_expression_listEx;
            	        }


            	        // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:535:14: (b= assignment_expression |rb= RANGE_LITERAL )
            	        {
            	            int alt14=2;
            	            switch ( LA(1) )
            	            {
            	            case CHARACTER_LITERAL:
            	            case DECIMAL_LITERAL:
            	            case FLOATING_POINT_LITERAL:
            	            case IDENTIFIER:
            	            case STRING_LITERAL:
            	            case 17:
            	            case 19:
            	            case 26:
            	            case 29:
            	            	{
            	            		alt14=1;
            	            	}
            	                break;
            	            case RANGE_LITERAL:
            	            	{
            	            		alt14=2;
            	            	}
            	                break;

            	            default:
            	                CONSTRUCTEX();
            	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	                EXCEPTION->message      = (void *)"";
            	                EXCEPTION->decisionNum  = 14;
            	                EXCEPTION->state        = 0;


            	                goto ruleconstant_expression_listEx;

            	            }

            	            switch (alt14)
            	            {
            	        	case 1:
            	        	    // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:535:15: b= assignment_expression
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_assignment_expression_in_constant_expression_list993);
            	        	        b=assignment_expression(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleconstant_expression_listEx;
            	        	        }


            	        	        {

            	        	                              if ( b
            	        	            ->get_object_type() == thelist[0]->get_object_type() && b
            	        	            ->get_data_type() == thelist[0]->get_data_type() )
            	        	                              {
            	        	                                   thelist.push_back(b
            	        	            ); 
            	        	                              } 
            	        	                              else{
            	        	                              	//cout << "HIT AN ERROR IN A [LIST]" << endl;
            	        	                              	errored = true; 
            	        	                              }
            	        	                             
            	        	                         
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:547:17: rb= RANGE_LITERAL
            	        	    {
            	        	        rb = (pANTLR3_COMMON_TOKEN) MATCHT(RANGE_LITERAL, &FOLLOW_RANGE_LITERAL_in_constant_expression_list1033);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleconstant_expression_listEx;
            	        	        }


            	        	        {
            	        	             
            	        	                            vector<int> range = pANTLR3_COMMON_TOKEN_to_intvect(rb);
            	        	                            for(int i = 0; i < range.size(); i++ ){
            	        	                              thelist.push_back(new pqlsymbol(range[i]));
            	        	                            } 
            	        	                        
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

            	default:
            	    goto loop15;	/* break out of the loop */
            	    break;
                }
            }
            loop15: ; /* Jump out to here if this rule does not match */


            {

                         if(! errored)
                         {
                           result= new pqlsymbol( thelist );

                           /*cout << "did not hit an error" << endl;*/
                           /*cout << "The value of the expression list = " <<result
                ->value_to_string() << endl;*/
                         }
                         else 
                           result= new pqlsymbol(ERROR, "type mismatch in list");

                       
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleconstant_expression_listEx; /* Prevent compiler warnings */
    ruleconstant_expression_listEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return result;
}
/* $ANTLR end constant_expression_list */

/**
 * $ANTLR start atom
 * /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:568:1: atom returns [pqlsymbol * result] : (a= constant | '[' (b= constant_expression_list )? ']' | '{' (b= constant_expression_list )? '}' );
 */
static pqlsymbol *
atom(ppqlParser ctx)
{
    pqlsymbol * result;


    pqlsymbol * a;
    #undef	RETURN_TYPE_a
    #define	RETURN_TYPE_a pqlsymbol *

    pqlsymbol * b;
    #undef	RETURN_TYPE_b
    #define	RETURN_TYPE_b pqlsymbol *

    /* Initialize rule variables
     */


          bool emptylist = true;
          bool errored = false;
      
    {
        {
            //  /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:575:3: (a= constant | '[' (b= constant_expression_list )? ']' | '{' (b= constant_expression_list )? '}' )

            ANTLR3_UINT32 alt18;

            alt18=3;

            switch ( LA(1) )
            {
            case CHARACTER_LITERAL:
            case DECIMAL_LITERAL:
            case FLOATING_POINT_LITERAL:
            case STRING_LITERAL:
            	{
            		alt18=1;
            	}
                break;
            case 26:
            	{
            		alt18=2;
            	}
                break;
            case 29:
            	{
            		alt18=3;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 18;
                EXCEPTION->state        = 0;


                goto ruleatomEx;

            }

            switch (alt18)
            {
        	case 1:
        	    // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:575:3: a= constant
        	    {
        	        FOLLOWPUSH(FOLLOW_constant_in_atom1117);
        	        a=constant(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomEx;
        	        }


        	        {

        	            /*cout << "DECIMAL_LITERAL = " << a
        	            ->value_to_string() << endl;*/
        	            result= 
        	            a
        	            ;

        	            /*cout << "DECIMAL_LITERAL = " << result
        	            ->value_to_string() << endl;*/


        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:581:2: '[' (b= constant_expression_list )? ']'
        	    {
        	         MATCHT(26, &FOLLOW_26_in_atom1123);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomEx;
        	        }


        	        // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:582:3: (b= constant_expression_list )?
        	        {
        	            int alt16=2;
        	            switch ( LA(1) )
        	            {
        	                case CHARACTER_LITERAL:
        	                case DECIMAL_LITERAL:
        	                case FLOATING_POINT_LITERAL:
        	                case IDENTIFIER:
        	                case RANGE_LITERAL:
        	                case STRING_LITERAL:
        	                case 17:
        	                case 19:
        	                case 26:
        	                case 29:
        	                	{
        	                		alt16=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt16)
        	            {
        	        	case 1:
        	        	    // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:583:7: b= constant_expression_list
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_constant_expression_list_in_atom1140);
        	        	        b=constant_expression_list(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleatomEx;
        	        	        }


        	        	        {

        	        	                    result= 
        	        	            b
        	        	            ;

        	        	                    emptylist = false; 
        	        	                  
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	         MATCHT(27, &FOLLOW_27_in_atom1159);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomEx;
        	        }


        	        {

        	               if (emptylist == true)
        	               {
        	                 result= new pqlsymbol();

        	               }
        	             
        	        }


        	    }
        	    break;
        	case 3:
        	    // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:596:4: '{' (b= constant_expression_list )? '}'
        	    {
        	         MATCHT(29, &FOLLOW_29_in_atom1167);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomEx;
        	        }


        	        // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:596:8: (b= constant_expression_list )?
        	        {
        	            int alt17=2;
        	            switch ( LA(1) )
        	            {
        	                case CHARACTER_LITERAL:
        	                case DECIMAL_LITERAL:
        	                case FLOATING_POINT_LITERAL:
        	                case IDENTIFIER:
        	                case RANGE_LITERAL:
        	                case STRING_LITERAL:
        	                case 17:
        	                case 19:
        	                case 26:
        	                case 29:
        	                	{
        	                		alt17=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt17)
        	            {
        	        	case 1:
        	        	    // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:597:2: b= constant_expression_list
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_constant_expression_list_in_atom1176);
        	        	        b=constant_expression_list(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleatomEx;
        	        	        }


        	        	        {

        	        	                    //set<int> *tempset  = new set<int>;
        	        	                    vector<int> tempvect = b
        	        	            ->get_int_vect();
        	        	                    std::set<unsigned int> tempset( tempvect.begin(), tempvect.end() );
        	        	                    result= new pqlsymbol(tempset);

        	        	                     emptylist = false;

        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	         MATCHT(30, &FOLLOW_30_in_atom1184);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomEx;
        	        }


        	        {

        	               if (emptylist == true)
        	               {
        	                 set<unsigned int> tempset;
        	                 result= new pqlsymbol(tempset);

        	               }

        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleatomEx; /* Prevent compiler warnings */
    ruleatomEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return result;
}
/* $ANTLR end atom */

/**
 * $ANTLR start constant
 * /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:618:1: constant returns [pqlsymbol * result] : ( (a= DECIMAL_LITERAL ) | (a= CHARACTER_LITERAL ) | (a= STRING_LITERAL ) | (a= FLOATING_POINT_LITERAL ) );
 */
static pqlsymbol *
constant(ppqlParser ctx)
{
    pqlsymbol * result;


    pANTLR3_COMMON_TOKEN    a;

    /* Initialize rule variables
     */

    a       = NULL;

    {
        {
            //  /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:620:7: ( (a= DECIMAL_LITERAL ) | (a= CHARACTER_LITERAL ) | (a= STRING_LITERAL ) | (a= FLOATING_POINT_LITERAL ) )

            ANTLR3_UINT32 alt19;

            alt19=4;

            switch ( LA(1) )
            {
            case DECIMAL_LITERAL:
            	{
            		alt19=1;
            	}
                break;
            case CHARACTER_LITERAL:
            	{
            		alt19=2;
            	}
                break;
            case STRING_LITERAL:
            	{
            		alt19=3;
            	}
                break;
            case FLOATING_POINT_LITERAL:
            	{
            		alt19=4;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 19;
                EXCEPTION->state        = 0;


                goto ruleconstantEx;

            }

            switch (alt19)
            {
        	case 1:
        	    // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:620:11: (a= DECIMAL_LITERAL )
        	    {
        	        // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:620:11: (a= DECIMAL_LITERAL )
        	        // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:620:13: a= DECIMAL_LITERAL
        	        {
        	            a = (pANTLR3_COMMON_TOKEN) MATCHT(DECIMAL_LITERAL, &FOLLOW_DECIMAL_LITERAL_in_constant1222);
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleconstantEx;
        	            }


        	            {

        	                    	/*cout << "DECIMAL_LITERAL = " << pANTLR3_COMMON_TOKEN_to_int(a) << endl;*/
        	                    	
        	                result=  new pqlsymbol( pANTLR3_COMMON_TOKEN_to_int(a)  );

        	                    
        	            }


        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:625:8: (a= CHARACTER_LITERAL )
        	    {
        	        // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:625:8: (a= CHARACTER_LITERAL )
        	        // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:625:10: a= CHARACTER_LITERAL
        	        {
        	            a = (pANTLR3_COMMON_TOKEN) MATCHT(CHARACTER_LITERAL, &FOLLOW_CHARACTER_LITERAL_in_constant1246);
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleconstantEx;
        	            }


        	            {

        	                    	/*cout <<"CHARACTER_LITERAL = " <<  pANTLR3_COMMON_TOKEN_to_string(a) << endl;*/
        	                    	
        	                result= new pqlsymbol( pANTLR3_COMMON_TOKEN_to_string(a) );

        	                    
        	            }


        	        }


        	    }
        	    break;
        	case 3:
        	    // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:630:8: (a= STRING_LITERAL )
        	    {
        	        // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:630:8: (a= STRING_LITERAL )
        	        // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:630:10: a= STRING_LITERAL
        	        {
        	            a = (pANTLR3_COMMON_TOKEN) MATCHT(STRING_LITERAL, &FOLLOW_STRING_LITERAL_in_constant1271);
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleconstantEx;
        	            }


        	            {

        	                    	/*cout << "STRING_LITERAL = " << pANTLR3_COMMON_TOKEN_to_string(a) << endl;*/
        	                    	
        	                result=  new pqlsymbol( pANTLR3_COMMON_TOKEN_string_lit_to_string( a)  );

        	                    
        	            }


        	        }


        	    }
        	    break;
        	case 4:
        	    // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:635:8: (a= FLOATING_POINT_LITERAL )
        	    {
        	        // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:635:8: (a= FLOATING_POINT_LITERAL )
        	        // /home/macember/Desktop/URSI/TreeHouse-Private/TreeHouse/pql.g:635:10: a= FLOATING_POINT_LITERAL
        	        {
        	            a = (pANTLR3_COMMON_TOKEN) MATCHT(FLOATING_POINT_LITERAL, &FOLLOW_FLOATING_POINT_LITERAL_in_constant1296);
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleconstantEx;
        	            }


        	            {

        	                    	/*cout << "FLOATING_POINT_LITERAL = " << pANTLR3_COMMON_TOKEN_to_double(a) << endl;*/
        	                    	 
        	                result=  new pqlsymbol( pANTLR3_COMMON_TOKEN_to_double(a) );

        	                    
        	            }


        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleconstantEx; /* Prevent compiler warnings */
    ruleconstantEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return result;
}
/* $ANTLR end constant */
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
/* End of syntactic predicates
 * ==============================================
 */






/* End of code
 * =============================================================================
 */
