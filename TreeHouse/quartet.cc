#include "quartet.h"

using namespace std;


quartet::quartet(int a0, int a1, int b0, int b1){

A = make_pair(a0, a1);
B = make_pair(b0, b1);
//  a.first = a0;
//  a.second = a1;
//  b.first = b0;
//  b.second = b1;
}

quartet::quartet(){
 A = make_pair(-1, -1); //assign values to -1 to indicate there is not yet data
 B = make_pair(-1, -1);
}

quartet::quartet(iPair a, iPair b){
	A = a;
	B = b;
	}

iPair quartet::getA(){
 return A;
}

iPair quartet::getB(){
 return B;
}

void quartet::setA(int x, int y){
  A = make_pair(x, y);
} 

void quartet::setB(int x, int y){
  B = make_pair(x, y);
}

void quartet::print(){
 int vals[4];
 vals[0] = A.first; vals[1] = A.second;
 vals[2] = B.first; vals[3] = B.second;
 for(int i = 0; i < 4; i++){
	if(vals[i] == -1){
		cout << "? ";
		}
	else{
		cout << vals[i];
		if(i!=3) {cout << " ";}
		}
	if(i==1){cout << "|";}
	}
 cout << endl;
}

void printQuartets(vector<quartet> input){
 for(int i = 0; i < input.size(); i++){
	cout << i+1 << ": ";
	input.at(i).print();
	}
}

vector<quartet> generateQuartetsFromBipart(vector<bool> b){
  vector<int> ones, zeros; 
  for(int i = 0; i < b.size(); i++){
	if(b.at(i)==1){
		ones.push_back(i);
		}
	else{
		zeros.push_back(i);
		}
	}
  return generateQuartetsFromOnesZeros(ones, zeros);
}

void fillDifferenceVectors(vector<char> v1, vector<char> v2, vector<int> &sameOnes, vector<int> &sameZeros, vector<int> &uniqueOnesA, vector<int> &uniqueOnesB, vector<int> &uniqueZerosA, vector<int> &uniqueZerosB, vector<int> &OnesA, vector<int> &OnesB, vector<int> &ZerosA, vector<int> &ZerosB){
 
  //iterate through vectors, fill appropriate vectors
    if(v1.size()!=v2.size()){
	cerr << "fillDifferenceVectors Error!: the vectors are of different sizes!";
	return;
	}
  for(unsigned int i = 0; i < v1.size(); i++){
	if(v1.at(i)==1){
		OnesA.push_back(i);
		if(v2.at(i)==1) {sameOnes.push_back(i); OnesB.push_back(i);}
		else{uniqueOnesA.push_back(i); uniqueZerosB.push_back(i); ZerosB.push_back(i);}
		}
	else{//v1[i]==0
		ZerosA.push_back(i);
		if(v2.at(i)==0){sameZeros.push_back(i); ZerosB.push_back(i);}
		else{uniqueZerosA.push_back(i); uniqueOnesB.push_back(i); OnesB.push_back(i);}
		}
	}
}

void addMatchedPairs(vector<iPair> p1, vector<iPair> p2, vector<quartet> &retVec){
  for(vector<iPair>::iterator i = p1.begin(); i!=p1.end(); i++){
	for(vector<iPair>::iterator j = p2.begin(); j!=p2.end(); j++){
			retVec.push_back(quartet(*i, *j));
			}
		}
}

vector<quartet> generateDifferentQuartets(int bipartA, int bipartB){

vector<quartet> retVec;
/*first, we need to know a few vectors:
	Same1- the taxa which are one across both biparts
	Same0- the taxa which are zero across both biparts	
	unique1A- taxa which are 1 only in bipart A
	unique1B- taxa which are 1 only in bipart B
	unique0A and unique0B

Algorithm description:

we want to generate all quartets from one bipartition but not the other

This means we can match any pair except if the both ones are generated by same1 and the 0s are generated by same0

Step 1- match all 0s with 1s not generated by same1s
first, take all permutations of taxa in unique1A, and also match each taxa in unique1A with a single taxon in same1. 
	This ensures that all of these pairs of 1s are those that can be generated by bipart1 but NOT bipart2
	Now, match all those pairs with the pairs that can be generated by 0s in bipart 1

For instance, suppose bipart A has 1s for taxa {0, 2, 3, 5, and 7} and both biparts had 1 at {5 7}. This means the
	unique pairs of 1s are {0/2, 0/3, 2/3,   |||  0/5, 2/5, 3/5, 0/7, 2/7, 3/7}. The ||| represents
	where the algorithm goes from making pairs from uniqueA to matching 1 taxon from uniqueA with each taxon 	 in shared1. 

Step 2- match all 1s generated with same1s with 0s unique to bipartition (i.e. not in same 0)
	Take same1s and create pairs out of it. Then generate pairs of 0s not possible by same 0 by 
	taking all permutations of unique0, and also matching each taxon in same0 with each taxon in unique0 
Step 3- repeat steps 1 and 2 with second bipartition


*/
 vector<char> A = copyToCharVector(biparttable.full_bitstring(bipartA), ::NUM_TAXA);
 vector<char> B = copyToCharVector(biparttable.full_bitstring(bipartB), ::NUM_TAXA);
 //optimization note- instead of calling sharedOnes then sharedZeros, we could make a function
	//that passes once through the vectors and puts elements in sharedOnes or sharedZero (or neither)
 vector<int> sameOnes, sameZeros, uniqueOnesA, uniqueOnesB, uniqueZerosA, uniqueZerosB, OnesA, OnesB, ZerosA, ZerosB;
 fillDifferenceVectors(A, B, sameOnes, sameZeros, uniqueOnesA, uniqueOnesB, uniqueZerosA, uniqueZerosB, OnesA, OnesB, ZerosA, ZerosB);
  
/*
cout << "printing vectors: Same ones " << endl;
printVector(sameOnes);
cout << "printing vectors: unique ones A" << endl;
printVector(uniqueOnesA);
cout << "printing vectors: unique ones B " << endl;
printVector(uniqueOnesB);
cout << "printing vectors: Same zeros " << endl;
printVector(sameZeros);
cout << "printing vectors: uniqueZerosA " << endl;
printVector(uniqueZerosA);
cout << "printing vectors: uniqueZerosB " << endl;
printVector(uniqueZerosB);
cout << "printing vectors: OnesA " << endl;
printVector(OnesA);
cout << "printing vectors: OnesB " << endl;
printVector(OnesB);
cout << "printing vectors: ZerosA " << endl;
printVector(ZerosA);
cout << "printing vectors: ZerosB " << endl;
printVector(ZerosB);
*/




//ALL QUARTETS IN VECTOR A BUT NOT IN VECTOR B
  //generate all iPairs of nChoose2 from uniqueOnesA, then match each uniqueOnesA with each sameOnes 
  //pairsA is all of the iPairs that can be generated from 1s in A that AREN'T shared
 
 vector<iPair> uniquePairs1A = nChooseTwo(uniqueOnesA);
  vector<iPair> matchedOnesA = matchTaxa(uniqueOnesA, sameOnes);
  uniquePairs1A.insert(uniquePairs1A.end(), matchedOnesA.begin(), matchedOnesA.end());
  //now, combine pairsOneA with all pairs of zeros from A
  vector<iPair> pairs0A = nChooseTwo(ZerosA);
  addMatchedPairs(uniquePairs1A, pairs0A, retVec);
//now we need to match all permutations of shared 1s with (unique 0s + matched(unique0s, shared0s)
  vector<iPair> uniquePairs0A = nChooseTwo(uniqueZerosA);
  vector<iPair> matchedZerosA = matchTaxa(uniqueZerosA, sameZeros); 
  uniquePairs0A.insert(uniquePairs0A.end(), matchedZerosA.begin(), matchedZerosA.end());
  addMatchedPairs(nChooseTwo(sameOnes), uniquePairs0A, retVec);

//ALL QUARTETS IN VECTOR B BUT NOT IN VECTOR A

 vector<iPair> uniquePairs1B = nChooseTwo(uniqueOnesB);
  vector<iPair> matchedOnesB = matchTaxa(uniqueOnesB, sameOnes);
  uniquePairs1B.insert(uniquePairs1B.end(), matchedOnesB.begin(), matchedOnesB.end());
  //now, combine pairsOneB with all pairs of zeros from B
  vector<iPair> pairs0B = nChooseTwo(ZerosB);
  addMatchedPairs(uniquePairs1B, pairs0B, retVec);
//now we need to match all permutations of shared 1s with (unique 0s + matched(unique0s, shared0s)
  vector<iPair> uniquePairs0B = nChooseTwo(uniqueZerosB);
  vector<iPair> matchedZerosB = matchTaxa(uniqueZerosB, sameZeros); 
  uniquePairs0B.insert(uniquePairs0B.end(), matchedZerosB.begin(), matchedZerosB.end());
  addMatchedPairs(nChooseTwo(sameOnes), uniquePairs0B, retVec);




  return retVec;
}



vector<iPair> nChooseTwo(vector<int> in)
{
//generates all pairs of nChoose2 from input vector
//size of return vector is   in.size() choose 2
 vector<iPair> ret;
  if(in.size()<2){ //make sure our input is big enough
	return ret;
	}
 for(vector<int>::iterator i = in.begin(); i!=in.end()-1; i++){
	for(vector<int>::iterator j = i+1; j!=in.end(); j++){
		ret.push_back(make_pair(*i, *j));	
		}
	}
}

vector<iPair> matchTaxa(vector<int> A, vector<int> B){
//makes all iPairs by matching one taxon from A and one taxon from B
//size of return vector is A.size()*B.size()
 vector<iPair> ret;
  for(vector<int>::iterator i = A.begin(); i!=A.end(); i++){
	for(vector<int>::iterator j=B.begin(); j!=B.end(); j++){
		ret.push_back(make_pair(*i, *j));	
		}
	}
return ret;
}

vector<quartet> generateSameQuartets(int bipartA, int bipartB){
  vector<char> A = copyToCharVector(biparttable.full_bitstring(bipartA), ::NUM_TAXA);
  vector<char> B = copyToCharVector(biparttable.full_bitstring(bipartB), ::NUM_TAXA);
  return (generateQuartetsFromOnesZeros(chSharedOnes(A,B), chSharedZeros(A,B)));
}

vector<quartet> generateQuartetsFromBipart(int b){
  //b is the index of the bipartition in biparttable.bipartitions
  //first, get the bitstring and map all of the 1s to one vector and all of the 
	//0s to another. NOTE with hetero trees this can be tricky, since taxa might
	//not exist even if the bitstring has a '0' for them
  vector<int> ones;
  vector<int> zeros;
  for(int i = 0; i < biparttable.length_of_bitstrings.at(b); i++){
	if(biparttable.bipartitions.at(b)[i]==false){
		zeros.push_back(i);
		}
	else{
		ones.push_back(i);
		}
	}
  if(biparttable.length_of_bitstrings.at(b) > ::NUM_TAXA){ //make sure the next for loop terminates
	cerr << "generateQuartetsFromBipart error: Length of bitstring is greater than NUM_TAXA! This should never happen\n";
   	}
  else{
  	for(int i = biparttable.length_of_bitstrings.at(b); i < ::NUM_TAXA; i++){
		zeros.push_back(i);
		}
	}
//now we have ones and zeros, pass it to generateQuartetsFromOnesZeros
  return generateQuartetsFromOnesZeros(ones, zeros);
}


vector<quartet> generateQuartetsFromOnesZeros(vector<int> ones, vector<int> zeros){
  vector<quartet> ret;
	if(ones.size() < 2 || zeros.size() < 2)
	{
	return ret;
	}

	//first, store all of the pairs from zeros in a vector so we don't have too many
	//	nested loops
	  vector<iPair> zerosPairs;
	  for(int i = 0; i < zeros.size()-1; i++){
		for(int j = i+1; j < zeros.size(); j++){	
			zerosPairs.push_back(make_pair(zeros.at(i), zeros.at(j)));
			}
	 	}

	//now we have to choose 2 from each of these vectors. We know both are of at least size 2
	  for(int i = 0; i < ones.size()-1; i++){
		for(int j = i+1; j < ones.size(); j++){
			iPair p = make_pair(ones.at(i), ones.at(j));
			for(vector<iPair>::iterator k = zerosPairs.begin(); k!= zerosPairs.end(); k++){
				//add a quartet of both pairs
				ret.push_back(quartet(p, *k));
				}
			}
		}
	return ret;
}

unsigned int getNumDifferentQuartets(int a, int b){
//quick optimization- if both ints are the same, we're comparing the same vector
 //if(a==b){
 //return 0;
//	}

//takes two bipartitions as input, returns the number of quartets that they do NOT share
  vector<char> A = copyToCharVector(biparttable.full_bitstring(a), ::NUM_TAXA);
  vector<char> B = copyToCharVector(biparttable.full_bitstring(b), ::NUM_TAXA);

  return(getNumDifferentQuartets(A, B));
}

unsigned int getNumDifferentQuartets(vector<char> a, vector<char> b){
//takes two bipartitions as input, returns the number of quartets that they do NOT share
  //first, take the AND and the OR of the vectors. AND tells us which taxa are 1s in both
  //OR tells us which taxa are 0s in both

  //then, count the number of quartets that as if the bipartition was only the common 1s and 0s
  //this is the number of quartets both biparts have in common
  int commonOnes = chNumberOfOnes(chAND(a, b));
  int commonZeros = chNumberOfZeros(chOR(a, b));  
  unsigned int commonQuartets = getNumQuartets(commonOnes, commonZeros);
  unsigned int quartetsA = getNumQuartets(a);
  unsigned int quartetsB = getNumQuartets(b);

 return (quartetsA + quartetsB - (2*commonQuartets));

//TODO- check if inverting the 1s and 0s produces a different result
}

unsigned int getNumQuartets(int b){
  //takes the index of a bipartition and counts the number of quartets implied by it
  int nOnes = biparttable.number_of_ones(b);
  int nZeros = biparttable.number_of_zeros(b);
  cout << "get num quartets: num 0s is " << nZeros << " num 1s is: " << nOnes << endl;
  //quartets = (nOnes choose 2) * (nZeros choose 2) 
  return(getNumQuartets(nOnes,nZeros));

}

unsigned int getNumQuartets(vector<bool> bipart){
  int nOnes, nZeros;
  nOnes = nZeros = 0;
  for(vector<bool>::iterator it = bipart.begin(); it!=bipart.end(); it++){
	if(*it){
		nOnes++;
		}
	else{
		nZeros++;
		}
	}
  return(getNumQuartets(nOnes,nZeros));
}

unsigned int getNumQuartets(vector<char> bipart){
  int nOnes, nZeros;
  nOnes = nZeros = 0;
  for(vector<char>::iterator it = bipart.begin(); it!=bipart.end(); it++){
	if(*it==1){
		nOnes++;
		}
	else{
		nZeros++;
		}
	}
  cout << "get num quartets: num 0s is " << nZeros << " num 1s is: " << nOnes << endl;
  return(getNumQuartets(nOnes,nZeros));
}



unsigned int getNumQuartets(int nOnes, int nZeros){
  return (  (factorial(nOnes) / (2 * factorial(nOnes-2))) * (factorial(nZeros) / (2 * factorial(nZeros-2))) );
}



void TESTSTUFF(){
cout << "QUARTETS FROM BIPARTITION 7\n";
printQuartets(generateQuartetsFromBipart(7));
cout << "QUARTETS FROM BIPARTITION 12\n";
printQuartets(generateQuartetsFromBipart(12));
cout << "Number of quartets in bipartition 7: " << getNumQuartets(7) << endl;
cout << "Number of quartets in bipartition 12: " << getNumQuartets(12) << endl;

char bipart7[] = {0,0,1,1,0,1,0,1,1,1};
vector<char> bipartFive;
bipartFive.assign(bipart7, bipart7+10);
cout << "Number of quartets in bipartition 7: " << getNumQuartets(bipartFive) << endl;

int diffQuartets = getNumDifferentQuartets(7,7);
cout << "different quartets between bipart 7 and 7 is: " << diffQuartets << endl;

diffQuartets = getNumDifferentQuartets(12,12);
cout << "different quartets between bipart 12 and 12 is: " << diffQuartets << endl;

diffQuartets = getNumDifferentQuartets(7,12);
cout << "different quartets between bipart 12 and 12 is: " << diffQuartets << endl;

cout << "about to get same quartets between 7 and 12" << endl;
printQuartets(generateSameQuartets(7, 12));
cout << "about to get different quartets between 7 and 12" << endl;
printQuartets(generateDifferentQuartets(7, 12));
}


